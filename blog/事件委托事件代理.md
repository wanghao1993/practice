# 事件委托

通俗来讲就是把子元素的事件委托到外层元素去执行，当事件作用到当前元素的时候，会冒泡到父元素或者外层元素去执行，说到这里就不得不说一下js的事件流

# 事件冒泡 和 事件补获

事件补获，最早是由IE团队提出，事件冒泡是由Netscape团队提出的。

## 事件冒泡

事件冒泡，事件开始从具体的节点出发，逐步向上冒泡到外层节点。例如：点击id为a的div时，事件会一步步向上传递 a=> b => c，当我们点击click的时候，会依次输出123

```html
<div id='c' onclick='console.log(3)'>
    <div id='b' onclick='console.log(2)'>
        <div id='a' onclick='console.log(1)'>
            click
        </div>
    </div>
</div>
```

## 事件捕获

虽然事件捕获是 Netscape 唯一支持的事件流模型，但 IE9、Safari、Chrome、Opera 和 Firefox 目前也都支持这种事件流模型。尽管“DOM2 级事件”规范要求事件应该从 document 对象
开始传播，但这些浏览器都是从 window 对象开始捕获事件的。
由于老版本的浏览器不支持，因此很少有人使用事件捕获。

# DOM事件流

DOM事件流分三个阶段，捕获阶段，目标阶段和冒泡阶段，DOM事件流又分为DOM0级和DOM2级。

## DOM0级事件处理程序

比如我们常见的click，load等等，DOM0级别事件被认定是元素的方法，所以其中this为元素本身，其作用域也是当前目标元素。
```html
<div id='a' onclick='console.log(this.id)'>
    click
</div>
```
打印出来的this 就是元素本身。清除DOM0级事件可以直接赋值为null就会清除掉。
```js

target.onclick = null

```

## DOM2级事件处理程序

DOM2级事件提供了两个方法，即大名鼎鼎的 <font style='color: #dd6633'>addEventListener</font> 和 <font style='color: #dd6633'>removeEventListener</font>，
他们都提供了三个参数。1.事件名称 2.事件方法 3.事件是在捕获阶段执行，还是在冒泡阶段执行，类型为布尔值，true在捕获阶段，false在冒泡阶段，默认为false

### addEventListener
```js
var target = document.getElementById('a')
target.addEventListener('click', function () {
    console.log(this.id)
}, false)
```
DOM2级事件，不会和DOM0级的冲突，所以在click的时候。会先打印this，再打印id，同时可以添加多个click事件,此时会先打印id，在打印 hello world，执行顺序和添加顺序保持一致
```js
var target = document.getElementById('a')
target.addEventListener('click', function () {
    console.log(this.id)
}, false)

target.addEventListener('click', function () {
    console.log('hello world')
}, false)
```

### removeEventListener

用于移除事件，移除事件的时候，必须的有两个参数，事件名称和处理函数。函数必须为是同一个函数，否则无法移除。

```js
var target = document.getElementById('a')
function sayHello () {
    console.log('hello world')
}
target.addEventListener('click', sayHello, false)

target.removeEventListener('click', function () {
    console.log('hello world')
}, false)
// 无效不能移除

target.removeEventListener('click', sayHello, false)
// 有效
```